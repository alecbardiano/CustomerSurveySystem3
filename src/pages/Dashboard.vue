<template>
  <div class="q-pa-md">
    <!-- @update:model-value="build()"  -->
       <div class="row">
          <div class="col-3"> <q-select   outlined v-model="modeDashboard" style="max-width: 200px" :options="modeOptions" width="30px" label="Mode" /></div>
          <div class="col-6"> 
            <q-select  v-if="modeDashboard == 'Annual'"  outlined v-model="yearTsr" style="max-width: 200px" option-label="text" :options="yearOptions" width="30px" label="Year" />
            <div class="row"  v-if="modeDashboard == 'Quarterly'">
              <div class="col-3"><q-select  outlined v-model="yearTsrQuarter" style="max-width: 200px" option-label="text" :options="yearOptions" width="30px" label="Year" /></div>
              
              <div class="col-6"><q-select  outlined v-model="quarterTSR" option-value="value" style="max-width: 200px" :options="quarterOptions" width="30px" label="Quarter" /></div>
            </div>

             <div class="row"  v-if="modeDashboard == 'Date Range'">
              <q-form ref="dateform" @submit="submitDate()">
                  
                  <div class="row inline">
                  <q-input outlined filled mask="date" v-model="beforeDate" lazy-rules :rules="[val => val <= afterDate || 'Field should be earlier than after date']" placeholder="mm/dd/yy" hint="Start Date" >
                    <template v-slot:append>
                      <q-icon name="event" class="cursor-pointer">
                        <q-popup-proxy ref="qDateProxy" transition-show="scale" transition-hide="scale">
                          <q-date v-model="beforeDate">
                            <div class="row items-center justify-end">
                              <q-btn v-close-popup label="Close" color="primary" flat />
                            </div>
                          </q-date>
                        </q-popup-proxy>
                      </q-icon>
                    </template>
                  </q-input> 
                  <q-input outlined filled mask="date" style="padding-left: 25px" v-model="afterDate" lazy-rules :rules="[val => val >= beforeDate || 'Field should be later than before date']"   placeholder="mm/dd/yy" hint="End Date" >
                    <template v-slot:append>
                      <q-icon name="event" class="cursor-pointer">
                        <q-popup-proxy ref="qDateProxy" transition-show="scale" transition-hide="scale">
                          <q-date v-model="afterDate">
                            <div class="row items-center justify-end">
                              <q-btn v-close-popup label="Close" color="primary" flat />
                            </div>
                          </q-date>
                        </q-popup-proxy>
                      </q-icon>
                    </template>
                  </q-input>

                  <q-btn
                    type="submit"
                    label="Go"
                    color="primary"
                    style="margin-left: 25px; width: 70px; height: 25px;"
                 />
                </div>
    
                </q-form>
            </div>
          </div>
           
      </div>
        <!-- <div> <q-select   outlined v-model="yearTsr" style="max-width: 200px" option-label="text" :options="yearOptions" width="30px" label="Year" /></div> -->
  
      
    </div>

   

  <div class="q-pa-md">
    
      <div class="layout-padding ">
      <div class="flex wrap gutter">
        <div class="width-1of3 sm-auto">
          <card-dashboard-feedback-count
            title= "Total TSRs"
            backgroundColor="green"
            icon-name="local_post_office"
            :total="totalTsrs">
          </card-dashboard-feedback-count>
        </div>
        <div class="width-1of3 sm-auto">
          <card-dashboard-feedback-count  @click="callCardData(1)" title="Negative Feedback" backgroundColor="red" :total="totalNegative" > </card-dashboard-feedback-count>
         
        </div>
        <div class="width-1of3 sm-auto">
          <card-dashboard-feedback-count
            @click="callCardData(2)" 
            title="Positive Feedback"
            backgroundColor="blue"
            :total="totalPositive">
          </card-dashboard-feedback-count>
        </div>

        <!-- <div class="width-1of3 sm-auto">
          <card-dashboard-feedback-count
            @click="callCardData(2)" 
            title="No Feedback"
            backgroundColor="blue"
            :total="totalNoFeedback">
          </card-dashboard-feedback-count>
        </div> -->
      </div>
      </div>  
  </div>
  <div class="q-pa-md">
    <div class="layout-padding ">
      <div class="flex wrap gutter">
        <div class="q-pa-md row items-start q-gutter-md">
          <q-card class="my-card">
            <q-card-section>
              <doughnut-chart :labels="chartDataModelLabel" :label="'Overall Performance of the Center Based on CSS Responses'" :chartData="chartDataModelData" />
            </q-card-section>
          </q-card>
        </div>
         <div class="q-pa-md row items-start q-gutter-md">
          <q-card class="my-card">
              <q-card-section>
                <bar-chart :labels="chartDataModelCustomersLabel" :label="'Total Number of CSM Respondents Per Month'" :chartData="chartDataModelCustomersData" />
              </q-card-section>
          </q-card>
        </div>
        <!-- <div class="q-pa-md row items-start q-gutter-md">
          <q-card class="my-card">
            <q-card-section>
              <bar-chart :labels="chartDataModelCustomersLabel" :label="'Number of Customers and CSM Respondents Per Service Area'" :chartData="chartDataModelCustomersData" />
            </q-card-section>
          </q-card>
        </div> -->
        
        
      </div>
    </div>
  </div>
  <div class="q-pa-md">
    <q-card>
      <line-chart :labelkeys="lineChartLabel" :labels="chartDataModelCustomersLabel" :label="'Number of Customers and CSM Respondents Per Service Area'" :chartData="chartDataModelNumberPerServiceArea" />
    </q-card>
  </div> 


  <!-- <div class="q-pa-md">
    <q-table
      :rows="tableData"
      :columns="columns2"
      row-key="col1"
      separator="cell"
    >
      <template v-slot:header="props">
          <q-tr>
            <q-th colspan="2" class="bg-teal-9 text-white">col type1</q-th>
            <q-th colspan="1" class="bg-deep-orange-9 text-white">col type2</q-th>
            <q-th colspan="3" class="bg-light-blue-9 text-white">col type3</q-th>
          </q-tr>
          <q-tr>
            <q-th key="col1" :props="props" class="bg-teal-9 text-white">col1</q-th>
            <q-th key="col2" :props="props" class="bg-deep-orange-9 text-white">col2</q-th>
            <q-th key="col1" :props="props" class="bg-deep-orange-9 text-white">col3</q-th>
            <q-th key="col4" :props="props" class="bg-light-blue-9 text-white">col4</q-th>
            <q-th key="col5" :props="props" class="bg-light-blue-9 text-white">col5</q-th>
            <q-th key="col6" :props="props" class="bg-light-blue-9 text-white">col6</q-th>
          </q-tr>
      </template>
      <template v-slot:body="props">
         {{props}} 
        <q-td v-for="row in props.row" v-bind:key="row">
          {{ row }}
        </q-td>
      </template>
    </q-table>
  </div> -->

  <!-- <div class="q-pa-md">
    <div class="row">
      <q-form ref="dateform">
        <div class="row inline">
          <q-input outlined filled mask="date" v-model="beforeDate" lazy-rules :rules="[val => val <= afterDate || 'Field should be earlier than after date']" placeholder="mm/dd/yy" hint="Start Date" >
            <template v-slot:append>
              <q-icon name="event" class="cursor-pointer">
                <q-popup-proxy ref="qDateProxy" transition-show="scale" transition-hide="scale">
                  <q-date v-model="beforeDate">
                    <div class="row items-center justify-end">
                      <q-btn v-close-popup label="Close" color="primary" flat />
                    </div>
                  </q-date>
                </q-popup-proxy>
              </q-icon>
            </template>
          </q-input> 
           :rules="[val => !!val || 'Field is required', val => !isNaN(val) || 'Field should be a number']"
          <q-input outlined filled mask="date" v-model="afterDate" lazy-rules :rules="[val => val >= beforeDate || 'Field should be later than before date']"   placeholder="mm/dd/yy" hint="End Date" style=" margin-left: 40px">
            <template v-slot:append>
              <q-icon name="event" class="cursor-pointer">
                <q-popup-proxy ref="qDateProxy" transition-show="scale" transition-hide="scale">
                  <q-date v-model="afterDate">
                    <div class="row items-center justify-end">
                      <q-btn v-close-popup label="Close" color="primary" flat />
                    </div>
                  </q-date>
                </q-popup-proxy>
              </q-icon>
            </template>
          </q-input>
        </div>
      </q-form>
    </div>
  </div> -->

  

    
    
  <div class="q-pa-md">
   <q-table
      :rows="rowsOverallPerformance"
      class="my-sticky-header-table"
      :columns="colsOverallPerformance"
      row-key="col1"
      separator="cell"
      title="Overall Performance of the Center Based on CSS Responses"
      style="height: 500px"
      :rows-per-page-options="[0]"
    >
    
     <template  v-slot:header>
       <!-- {{props}} -->
      <!-- <div  -->
          <q-tr>
            <q-th key="serviceArea" style="width: 250px" class="bg-light-blue-9 black-white"></q-th>
            <q-th key="percentage" style="width: 100px" class="bg-light-blue-9 black-white"></q-th>
            <q-th v-for="(col) in divisions" v-bind:key="col.name" v-bind:colspan="col.count"> {{col.division}}</q-th>
          </q-tr>
          <q-tr>
            <q-th  v-for="col in colsOverallPerformance"  v-bind:key="col.name" class="bg-light-blue-9 black-white" > {{col.name}}</q-th>
          </q-tr>
          
          
      <!-- </div> -->
        
    </template>
    <template v-slot:bottom-row>
        <q-tr>
          <q-td>Total:</q-td>
          <q-td style="text-align: center" v-bind:key="column.key" v-for="column in totalPerField">
              <p v-if="column.value != 0  ">{{ column.value }}</p>
            </q-td>
        </q-tr>
      </template>
    </q-table>
  </div>

  <div class="q-pa-md">

    <q-table
      :rows="rowsnumberOfCustomers"
      :columns="colsnumberOfCustomers"
      class="my-sticky-header-table"
      row-key="col1"
      title="Number of Customers and CSM Respondents Per Service Area"
      separator="cell"
      :rows-per-page-options="[0]"
    >
    <template  v-slot:header>
       <!-- {{props}} -->
      <!-- <div  -->
        <q-tr>
          <q-th key="Month" style="width: 250px" class="primary"></q-th>
          <q-th v-for="(col) in divisions" v-bind:key="col.name" v-bind:colspan="col.count"> {{col.division}}</q-th>
          <q-th key="Total" style="width: 250px" class="primary"></q-th>
        </q-tr>
        <q-tr>
          <q-th  v-for="col in colsnumberOfCustomers"  v-bind:key="col.name" class="bg-light-blue-9 black-white" > {{col.name}}</q-th>
          
        </q-tr>
        
        
    <!-- </div> -->
      
  </template>

      <template v-slot:bottom-row>
        <q-tr>
          
          <q-td>
            Total Actual Respondents
          </q-td>
          <q-td style="text-align: center" v-bind:key="column.key" v-for="(column) in totalActualRespondents">
              {{column.value}}
              <!-- {{ column[key] }}  -->
               <!-- <p v-if="column.value != 0  "></p>  -->
          </q-td>
        </q-tr>
        <q-tr>
          <q-td >
            Total Actual No. of Customers Served
          </q-td>
          <q-td >
             {{}}
          </q-td>
        </q-tr>
        <q-tr>
          <q-td >
             Target No. of Respondents
          </q-td>
          <q-td style="text-align: center" v-bind:key="column.key" v-for="(column) in totalActualRespondents">
              {{column.value}}
              <!-- {{ column[key] }}  -->
               <!-- <p v-if="column.value != 0  "></p>  -->
          </q-td> 
        </q-tr>
        <q-tr>
          <q-td >
             Percentage
          </q-td>
          <q-td>
             {{}}
          </q-td>
        </q-tr>

      </template>
        
    </q-table>

      <q-dialog v-model="cardModal" :maximized="maximizedToggle"
  transition-show="slide-up"
  transition-hide="slide-down">
    <q-card  >
            <q-card-section class="bg-primary text-white">
              <div class="text-h5 inline">
                <span></span>
                <div class="fixed-right">
                <q-btn dense flat icon="minimize" @click="maximizedToggle = false" :disable="!maximizedToggle">
                  <q-tooltip v-if="maximizedToggle" class="bg-white text-primary">Minimize</q-tooltip>
                </q-btn>
                <q-btn dense flat icon="crop_square" @click="maximizedToggle = true" :disable="maximizedToggle">
                  <q-tooltip v-if="!maximizedToggle" class="bg-white text-primary">Maximize</q-tooltip>
                </q-btn>
                <q-btn dense flat icon="close" v-close-popup>
                  <q-tooltip class="bg-white text-primary">Close</q-tooltip>
                </q-btn>
                </div>
              </div>
            </q-card-section>

            <q-card-section class="row items-left">
               <q-table
                  v-if="cardData"
                  class="my-sticky-header-table"
                  
                  :title="cardTitle"
                  :rows="rows"
                  :columns="cardDataCols"
                  :filter="filter"
                  v-model:pagination="pagination"
                  @request="onRequestCard"
                  binary-state-sort
                  separator="cell"
                >
                 <template v-slot:top-right>
                  <q-input class="placeholderClass" borderless dense debounce="300" v-model="filter" placeholder="Search">
                    <template v-slot:append>
                      <q-icon class="searchClass" name="search" />
                    </template>
                  </q-input>
                </template>

               </q-table>
                <!-- <q-icon name="check" color="primary" text-color="white" /> @row-click="onRowClick" -->
                <!-- modal view answer -->
            <!-- <viewsurveyanswer v-model="tsrData" :cols="cols"></viewsurveyanswer> -->
            
            </q-card-section>

            <!-- <q-card-actions align="right">
                <q-btn flat label="Cancel" color="primary" v-close-popup />
                <q-btn flat label="Submit" @click="onSubmit" color="primary" v-close-popup />
            </q-card-actions> -->
          </q-card>
  </q-dialog>

  
  </div>

</template>


<script type="text/javascript">

  import { defineComponent, ref, reactive, computed, onMounted, watch, onBeforeUnmount } from 'vue'
  import { findOverallPerformanceCenterPercentage,findOverallPerformanceCenter,findNumberCustomer,getNegativeFeedbackDataRange,getPositiveFeedbackDataRange,countNegativeFeedbackByDateRange,countPositiveFeedbackByDateRange,getDivList, countPositiveFeedback, countNegativeFeedback, totalTsrsCount , totalTsrsCountByYear,getTsrYear, allOverAllRatingsFromApi, getNegativeFeedbackData,getPositiveFeedbackData,countNoFeedback, getNoAnswerFeedbackData,getTSRYearAndMonth,getAnswerBySearch,countAnswerBySearch,getCountServicePerDivision } from 'src/axioshelper.js'
  import CardDashboardFeedbackCount from '../components/CardDashboardFeedbackCount.vue'
  import { overAllColumns, overAllRows} from 'src/utils/dataRetrieveTables.js'
  import { Chart, registerables } from 'chart.js'
  import groupBy from 'lodash'
  import moment from 'moment';
  import {  useStore } from "vuex";
  import { exportFile, useQuasar} from 'quasar'

  // import PieChart from '../components/PieChart.vue'
  import DoughnutChart from '../components/DoughnutChart.vue'
  import BarChart from '../components/BarChart.vue'
  import LineChart from '../components/LineChart.vue'



  // import { BarChart, useBarChart } from 'vue-chart-3'


  Chart.register(...registerables);
  
  export default {
    name: 'Dashboard',
    components: {
      CardDashboardFeedbackCount,
      // PieChart,
      DoughnutChart,
      BarChart,
      LineChart
    },
    
    setup() {
      const dataValues = ref([30, 40, 60, 70, 5]);
      const totalNegative = ref(0);
      const totalPositive = ref(0);
      const totalNoFeedback = ref(0);
      const totalTsrs =  ref(0);
      const tsrs = ref([])
      const totalAnswerOverall = ref([])
      const totalNoResponse = ref(0)

      const mode = ref(null)

      const currentYear =  ref(new Date().getFullYear())

      const $q = useQuasar()

      const pagination = ref({
        sortBy: 'desc',
        descending: false,
        page: 1,
        rowsPerPage: 10,
        rowsNumber: 5,
        mode: 0
      })

      const modeDashboard = ref("Annual")

      watch(modeDashboard, (newValue, oldValue) => {

        yearTsr.value = null
        quarterTSR.value = null
        yearTsrQuarter.value = null
        beforeDate.value = null
        afterDate.value = null
        
        
        
      })



      const beforeDate = ref(null)
      const afterDate = ref(null)


      
      const chartDataModelLabel = ref([]) // overall
      const chartDataModelCustomersLabel = ref([])

      const chartDataModelData = ref([])
      const chartDataModelCustomersData = ref([])
      const chartDataModelNumberPerServiceArea = ref([])
      
      const lineChartLabel = ref([])

      // cardData
      const cardData = ref([])
      const cardDataCols = ref([])
      const cardTitle = ref('')


      let rows = ref([])

      const filter = ref(null)



      // const chartOptions =  ref({
      //   hoverBorderWidth: 20
      // })
      
      const divisions = ref([])
      const divisionsAndSections = ref([])
      const services = ref([])

      const rowsOverallPerformance = ref([])
      const rowsnumberOfCustomers = ref([])  
      const colsOverallPerformance = ref([])
      const colsnumberOfCustomers = ref([])

      const yearTsr = ref()
      const quarterTSR = ref()
      const yearTsrQuarter = ref()
      
      const columns = ref([])

      const store = useStore();

      const getterUser = computed(() => store.getters["auth/getUserProfile"]);



    //   fullName: function () {
    //   return this.firstName + ' ' + this.lastName
    // }

      // bottom row overall performance
      const totalPerField = ref([])

      // const yearOptions = ref([])

      // bottom row customer
      const totalActualRespondents = ref([])

      const showTextCard = ref(false)

      let timer

      // card modal

      const maximizedToggle = ref(true)
      const cardModal = ref(false)

      const  yearOptions = computed(() =>{
        let earliestYear = 2000;
        let yearArr = []
        let iterate = currentYear.value
        while (iterate >= earliestYear) {      
          yearArr.push(iterate)     
          iterate -= 1;    
        }
        return yearArr
      })

      const quarterOptions = [
        1,2,3,4
      ]

      const modeOptions = ref(["Annual", "Quarterly", "Date Range"])

      watch(yearTsr, (newValue, oldValue) => {
        if(yearTsr.value){
          showLoading()

          updateTables()
          LoadFeedbackCounts(newValue)
        }
        
      })
      
      

      watch(quarterTSR, (newValue, oldValue) => {

        
        if(quarterTSR.value){
          showLoading()
          switch(quarterTSR.value) {
            case 1:
              // code block
              beforeDate.value = new Date('01/01/'+yearTsrQuarter.value)
              afterDate.value = new Date('03/31/'+yearTsrQuarter.value)
              break;
            case 2:
              // code block
              beforeDate.value = new Date('04/01/'+yearTsrQuarter.value)
              afterDate.value = new Date('06/30/'+yearTsrQuarter.value)
              break;
            case 3:
              beforeDate.value = new Date('07/01/'+yearTsrQuarter.value)
              afterDate.value = new Date('09/30/'+yearTsrQuarter.value)
              // code block
              break;
            case 4:
              beforeDate.value = new Date('10/01/'+yearTsrQuarter.value)
              afterDate.value = new Date('12/31/'+yearTsrQuarter.value)
              // code block
              break;
            default:
              // code block
          }
          updateTables()
          // console.log("before,after,",before,after)
          LoadFeedbackCountsDateRange(beforeDate.value,afterDate.value)
        
        }
      })
    onBeforeUnmount(() => {
      if (timer !== void 0) {
        clearTimeout(timer)
        $q.loading.hide()
      }
    })

    function showLoading () {
      $q.loading.show({
        message: 'Please wait for data to be loaded..',
        boxClass: 'bg-grey-2 text-grey-9',
        spinnerColor: 'primary'
      })
    }

      // function()

    async function loadCharts(){
      
      let dataArr = []
      let custArr = []
      let custArrServiceArea = []
      // if(chartDataModelData.value.length > 0){

      if(chartDataModelLabel.value.length > 0 || chartDataModelCustomersLabel.value.length > 0 || lineChartLabel.value.length>0){
        chartDataModelLabel.value = []
        chartDataModelCustomersLabel.value = []
        lineChartLabel.value = []
      }
        
      // }else{
      // doughnut graph
      rowsOverallPerformance.value.forEach(element => {
      // console.log("11")
        chartDataModelLabel.value.push(element.servicearea)
        dataArr.push(element.countOverall)
        
      });
      let keys = []
      // bar graph
      rowsnumberOfCustomers.value.forEach(element => {
        if(keys.length == 0){
          keys = Object.keys(element)
        }
        chartDataModelCustomersLabel.value.push(element.month)
        custArr.push(element.total)
        
      });
      // format for charts
      if(modeDashboard.value == 'Date Range'){
        keys.pop()
        keys.pop()
        keys.pop() 
      }else{
        keys.shift()
        keys.shift()
        keys.shift()  
      }
      
      //line graph
      keys.forEach(element => {
        let arr = rowsnumberOfCustomers.value.map(a =>
          a[element] 
        )
        custArrServiceArea.push(arr)
        lineChartLabel.value.push(element)
        // console.log("custArrServiceArea",custArrServiceArea)
      });
      
      
      chartDataModelData.value = dataArr

      // rowsnumberOfCustomers.value.forEach(element => {
      //   console.log("rowsnumberOfCustomers", rowsnumberOfCustomers.value)
      //   chartDataModelCustomersLabel.value.push(element.month)
      //   custArr.push(element.total)
        
      // });
      chartDataModelCustomersData.value = custArr
      chartDataModelNumberPerServiceArea.value = custArrServiceArea

    }


    async function LoadFeedbackCounts(year){
      if (year){
        totalTsrs.value = await totalTsrsCountByYear(year)
      }else{
        totalTsrs.value = await totalTsrsCountByYear("")
      }
      

      totalNegative.value = await countNegativeFeedback(year)
      totalPositive.value = await countPositiveFeedback(year)
      totalNoFeedback.value = await countNoFeedback(year)
    }

    async function LoadFeedbackCountsDateRange(beforeDate,afterDate){
      totalTsrs.value = await totalTsrsCount(beforeDate,afterDate,"")
      totalNegative.value = await countNegativeFeedbackByDateRange("","",beforeDate,afterDate)
      totalPositive.value = await countPositiveFeedbackByDateRange("","",beforeDate,afterDate)
      // totalNoFeedback.value = await countNoFeedbackByDateRange(beforeDate,afterDate)
    }
    
    async function getAllTsrsByYearMonth (before,after){
      let tsrMonth
      let alltsrs = []
      let answerOverall = []
      let beforeMom = moment(before).month()
      let currYear = moment(before).year()
      let diffMonths = Math.floor(moment(after).diff(moment(before), 'months', true))
      
      for(let i=0 ; i<=diffMonths; i++){
        tsrMonth = await getTSRYearAndMonth(beforeMom,currYear)
        answerOverall = await allOverAllRatingsFromApi(beforeMom,currYear)
        // console.log("curryear", currYear)
        // console.log("beforeMom", beforeMom)
        tsrMonth.forEach(element => {
          tsrs.value.push(element)
        });
        answerOverall.forEach(element => {
          totalAnswerOverall.value.push(element)
          
        });
        if(beforeMom == 11){
          beforeMom = 0
          currYear += 1
        }else{
          beforeMom+= 1
      }
      
      
    }
    // console.log("give all the love" , alltsrs)
    return alltsrs  
  }

    

    async function updateTables(){
      // reset arrays

      rowsOverallPerformance.value = []
      rowsnumberOfCustomers.value = []
      totalActualRespondents.value = []
      totalAnswerOverall.value = []
      
      totalPerField.value = []
      let totalPercentRow = 0


      buildRowsCustomers()
      buildRowsOverallPerformance()

      
      
      tsrs.value = []
      // let a = await getTsrYear(currentYear.value)
      // console.log("aaaaa", a)
      
      if (yearTsr.value){
        let before = new Date(yearTsr.value, 0, 1)
        let after = new Date(yearTsr.value, 11, 31)
        let arr = await findNumberCustomer(before ,after)
        rowsnumberOfCustomers.value.forEach(row => {
          let totalPerMonth = 0
          arr.forEach(element => {
          let month = element.monthYear.toString().split('-')[1]
          if (row.id == month){
            row[element.keyDiv] = element.countDiv
            totalPerMonth += element.countDiv
            }
          }); 
          row.total = totalPerMonth
        })
        let arr2 = await findOverallPerformanceCenter(before ,after)
        let arr3 = await findOverallPerformanceCenterPercentage(before ,after)
        rowsOverallPerformance.value.forEach(row => {
          let totalPerMonth = 0
          arr2.forEach(element => {
          if (row.id == element.value.toString()){
            row[element.keyDiv] = element.resultPercent.toString() + '%'
            // totalPerMonth += element.countDiv
          }
          }); 
          arr3.forEach(element3 => {
          if (row.id == element3.value2.toString()){
            totalPercentRow += element3.resultPercent
            row['percentage'] = element3.resultPercent.toString() + '%'
            row['countOverall'] = parseFloat(element3.resultPercent)
            // totalPerMonth += element.countDiv
          }
          }); 
        })
      }
      else if(quarterTSR.value){
        let after
        let before
        switch(quarterTSR.value) {
          case 1:
            // code block
            before = new Date(yearTsrQuarter.value, 0, 1)
            after = new Date(yearTsrQuarter.value, 2, 31)
            break;
          case 2:
            // code block
            before = new Date(yearTsrQuarter.value, 3, 1)
            after = new Date(yearTsrQuarter.value, 5, 30)
            break;
          case 3:
            before = new Date(yearTsrQuarter.value, 6, 1)
            after = new Date(yearTsrQuarter.value, 8, 30)
            // code block
            break;
          case 4:
            before = new Date(yearTsrQuarter.value, 9, 1)
            after = new Date(yearTsrQuarter.value, 11, 31)
            // code block
            break;
          default:
            // code block
        }
        // months
        let arr = await findNumberCustomer(before ,after)
        rowsnumberOfCustomers.value.forEach(row => {
          let totalPerMonth = 0
          arr.forEach(element => {
          let month = element.monthYear.toString().split('-')[1]
          if (row.id == month){
            row[element.keyDiv] = element.countDiv
            totalPerMonth += element.countDiv
            }
          }); 
          row.total = totalPerMonth
        })
        //overall
        let arr2 = await findOverallPerformanceCenter(before ,after)
        let arr3 = await findOverallPerformanceCenterPercentage(before ,after)
        rowsOverallPerformance.value.forEach(row => {
          let totalPerMonth = 0
          arr2.forEach(element => {
          if (row.id == element.value.toString()){
            row[element.keyDiv] = element.resultPercent.toString() + '%'
            // totalPerMonth += element.countDiv
            }
          }); 
          arr3.forEach(element3 => {
          if (row.id == element3.value2.toString()){
            totalPercentRow += element3.resultPercent
            row['percentage'] = element3.resultPercent.toString() + '%'
            row['countOverall'] = parseFloat(element3.resultPercent)
            // totalPerMonth += element.countDiv
          }
          }); 
        })
      }
      else if(beforeDate.value && afterDate.value){
        let arr = await findNumberCustomer(beforeDate.value ,afterDate.value)
        rowsnumberOfCustomers.value.forEach(row => {
          let totalPerMonth = 0
          arr.forEach(element => {
          let month = element.monthYear.toString().split('-')[1]
          if (row.id == month){
            row[element.keyDiv] = element.countDiv
            totalPerMonth += element.countDiv
            }
          }); 
          row.total = totalPerMonth
        })
        let arr2 = await findOverallPerformanceCenter(beforeDate.value ,afterDate.value)
        let arr3 = await findOverallPerformanceCenterPercentage(beforeDate.value ,afterDate.value)
        rowsOverallPerformance.value.forEach(row => {
          let totalPerMonth = 0
          arr2.forEach(element => {
          if (row.id == element.value.toString()){
            row[element.keyDiv] = element.resultPercent.toString() + '%'
            // totalPerMonth += element.countDiv
            }
          }); 
          arr3.forEach(element3 => {
          if (row.id == element3.value2.toString()){
            totalPercentRow += element3.resultPercent
            row['percentage'] = element3.resultPercent.toString() + '%'
            row['countOverall'] = parseFloat(element3.resultPercent)
            // totalPerMonth += element.countDiv
          }
          }); 
        })
      }
      else{
        
        let arr = await findNumberCustomer("","")
        rowsnumberOfCustomers.value.forEach(row => {
          let totalPerMonth = 0
          arr.forEach(element => {
            let month = element.monthYear.toString().split('-')[1]
            if (row.id == month){
              row[element.keyDiv] = element.countDiv
              totalPerMonth += element.countDiv
            }
          }); 
          row.total = totalPerMonth
        
        
        });
        let arr2 = await findOverallPerformanceCenter("","")
        let arr3 = await findOverallPerformanceCenterPercentage("","")
        rowsOverallPerformance.value.forEach(row => {
          let totalPerMonth = 0
          arr2.forEach(element => {
          if (row.id == element.value.toString()){
            row[element.keyDiv] = element.resultPercent.toString() + '%'
            // totalPerMonth += element.countDiv
            }
          }); 
          arr3.forEach(element3 => {
          if (row.id == element3.value2.toString()){
            totalPercentRow += element3.resultPercent
            row['percentage'] = element3.resultPercent.toString() + '%'
            row['countOverall'] = parseFloat(element3.resultPercent)
            // totalPerMonth += element.countDiv
          }
          }); 
        })
        
      } 
          
        

         // Number of customers Row generation
        
        // group by months
        
        
        // total Respondents per month
          let totalRespondents = 0
          divisionsAndSections.value.forEach(key => {
                  
            let stringColField = key.keyname
            let resultTotal = rowsnumberOfCustomers.value.map(a => {
              if(isNaN(a[stringColField])){
                  a[stringColField] = 0
              }
              return a[stringColField]
            })
            // console.log("res", resultTotal)
            let atotal = resultTotal.reduce((a, b) => a + b, 0)
            
            // totalActualRespondents.value[stringColField] = atotal
            let tempObj = {}
            tempObj['value'] = atotal
            totalRespondents += atotal
            totalActualRespondents.value.push(tempObj)
          })
          // total respondents push to last array
          let total = {}
          total['value'] = totalRespondents
          totalActualRespondents.value.push(total)
          

        // total row add percentage field
        
        // });
        //total
        let tempObj = {}
        tempObj['value'] = totalPercentRow.toFixed(2).toString() + '%'
        totalPerField.value.push(tempObj)
        // console.log("totalPerField",totalPerField.value)

        divisionsAndSections.value.forEach(key => {
          
            let tempSecDivObj = {}
            let service = key.keyname
            let a = rowsOverallPerformance.value.map(a => a[service]);
            let sum = a.reduce((a, b) => parseFloat(a) + parseFloat(b), 0)
            sum = Math.round(sum)
            tempSecDivObj['value'] = sum.toFixed(2).toString() + '%'
            totalPerField.value.push(tempSecDivObj)
            
        })

          timer = void 0
          $q.loading.hide()
          loadCharts()
      }

    // async function updateTables(){
    //   // reset arrays

    //   rowsOverallPerformance.value = []
    //   rowsnumberOfCustomers.value = []
    //   totalActualRespondents.value = []
    //   totalAnswerOverall.value = []
      
    //   totalPerField.value = []


      

      
    //   const mainCounts = {
    //       5: 0, 
    //       4: 0,
    //       3: 0, 
    //       2: 0,
    //       1: 0,
    //       0: 0,
    //     };

      
    //   tsrs.value = []
    //   // let a = await getTsrYear(currentYear.value)
    //   // console.log("aaaaa", a)
      
    //   if (yearTsr.value){
    //     let tsrMonth
    //     let answersOverall
    //     for(let i=0 ; i<12; i++){
    //       tsrMonth = await getTSRYearAndMonth(i,yearTsr.value)
    //       answersOverall = await allOverAllRatingsFromApi(i,yearTsr.value)
    //       tsrMonth.forEach(element => {
    //         tsrs.value.push(element)
    //       });
    //       answersOverall.forEach(element => {
    //         totalAnswerOverall.value.push(element)
    //       });
          
    //     }
    //   }
    //   else if(quarterTSR.value){
    //     let tsrMonth
    //     let answersOverall
    //     let quart
    //     switch(quarterTSR.value) {
    //       case 1:
    //         // code block
    //         quart = 0
    //         break;
    //       case 2:
    //         // code block
    //         quart = 3
    //         break;
    //       case 3:
    //         quart = 6
    //         // code block
    //         break;
    //       case 4:
    //         quart = 9
    //         // code block
    //         break;
    //       default:
    //         // code block
    //     }
    //     for(let i=quart ; i<quart+3; i++){
    //       tsrMonth = await getTSRYearAndMonth(i,yearTsrQuarter.value)
    //       answersOverall = await allOverAllRatingsFromApi(i,yearTsrQuarter.value)
    //       tsrMonth.forEach(element => {
    //         tsrs.value.push(element)
    //       });
    //       answersOverall.forEach(element => {
    //         totalAnswerOverall.value.push(element)
    //       });
          
    //     }
    //   }
    //   else if(beforeDate.value && afterDate.value){
    //     console.log("here oh wtf")
    //     await getAllTsrsByYearMonth(beforeDate.value,afterDate.value)
    //     console.log("totalAnswerOverall.value.length(",totalAnswerOverall.value.length)
    //   }
    //   else{
    //     let tsrMonth
    //     let answersOverall
    //     for(let i=0 ; i<12; i++){
    //       tsrMonth = await getTSRYearAndMonth(i,currentYear.value)
    //       answersOverall = await allOverAllRatingsFromApi(i,currentYear.value)
    //       // console.log("answersOverall",answersOverall)
    //       tsrMonth.forEach(element => {
    //         tsrs.value.push(element)
    //       });
    //       answersOverall.forEach(element => {
    //         totalAnswerOverall.value.push(element)
    //       });
    //     }
    //     // tsrs.value = await getTsrYear(yearTsr.value)
    //     // totalAnswerOverall.value = await allOverAllRatingsFromApi("","",currentYear.value)
        
    //   }
    //   if(modeDashboard.value != "Date Range"){
    //     buildRowsCustomers()
    //     var result = _(tsrs.value)
    //     .groupBy(v => moment(v.submittedAt).format('MMMM'))
    //     .value();
    //     // console.log("results", result)

    //       for (var key in result) {
    //           let totalRespondentsPerMonth = 0
    //           if (result.hasOwnProperty(key)) {
    //             let row = {}
    //             let totalPerMonth = 0
    //             row['month'] = key
    //             // console.log("keys 777", key)
                
                
    //             let temp = result[key]
    //             // console.log("temp", temp)
    //             divisionsAndSections.value.forEach(key2 => {
                  
    //                 let stringColField = key2.keyname
    //                 // filter all data
    //                 let sample = temp.filter((elementTSR) => {
    //                 if(elementTSR.division === key2.division && elementTSR.service === key2.service){
    //                   // console.log(key2 + ' - ', element )
    //                   return elementTSR
    //                 }
                    
    //                 })
    //                 // console.log("rowsnumberOfCustomers",rowsnumberOfCustomers.value)
    //                 let x = rowsnumberOfCustomers.value.find(x => x.month === key);
    //                 x[stringColField] = sample.length
    //                 totalPerMonth += sample.length
    //             })
    //             let rowMonth = rowsnumberOfCustomers.value.find(x => x.month === key);
    //             // console.log("rowmonth error", rowMonth)
    //             rowMonth['total'] = totalPerMonth
    //             // console.log("totalpermonth", totalPerMonth)
                

                
    //           }
    //       }

    //   }else{
    //     var result = _(tsrs.value)
    //     .groupBy(v => moment(v.submittedAt).format('MMMM-YYYY'))
    //     .value();
    //     let index = 1
    //     for (var key in result) {
    //         if (result.hasOwnProperty(key)) {
    //           let row = {}
    //           let totalPerMonth = 0
    //           row['month'] = key
              
    //           let temp = result[key]
    //           divisionsAndSections.value.forEach(element => {
    //             let stringColField = element.keyname
    //               // filter all data
    //               let sample = temp.filter((elementTSR) => {
    //               if(elementTSR.tsrNo){
    //                 if(elementTSR.division == element.division && elementTSR.service == element.service){
    //                   // console.log("pasok oh loko" )
    //                   return elementTSR
    //                 }
    //               }
                  
    //               })
    //               row[stringColField] = sample.length ? sample.length : 0
    //               totalPerMonth += sample.length
    //           });
                  
    //           // total horizontal
    //           row['total'] = Math.round(totalPerMonth)
    //           row['id'] = index+=1
    //           // totalPerMonth
              
    //           rowsnumberOfCustomers.value.push(row)
    //         }
    //     }

    //   } 
      
    //   buildRowsOverallPerformance()

    //   console.log("totalAnswerOverall",totalAnswerOverall.value)

    //   totalAnswerOverall.value = totalAnswerOverall.value.filter(function (el) {
    //       return el.tsr != null;
    //     });
    //   // total overall 
    //   // key is the division
    //   // element is the service
    //     divisionsAndSections.value.forEach(key => {
           
    //         let stringColField = key.keyname
    //         // filter all answer overall specific to tsr
    //         let sample = totalAnswerOverall.value.filter((elementTSR) => {
    //         if(elementTSR.tsr){
    //           // console.log("elementTSR", elementTSR)
    //           if(elementTSR.tsr.division == key.division && elementTSR.tsr.service == key.service){
    //             return elementTSR
    //           }
    //         }
    //       })
          
    //       // count per service 
    //         const counts = {
    //           5: 0, 
    //           4: 0,
    //           3: 0, 
    //           2: 0,
    //           1: 0,
    //           0: 0
    //         };
    //         for (const element of sample) {
              
    //           let num = element.value
    //           if (num == 1){
    //             counts[1] +=1
    //             mainCounts[1] +=1
    //           }else if ( num == 2){
    //             counts[2] +=1
    //             mainCounts[2] +=1
    //           }else if(num ==3 ){
    //             counts[3] +=1
    //             mainCounts[3] +=1
    //           }else if(num == 4){
    //             counts[4] +=1
    //             mainCounts[4] +=1
    //           }else if(num == 5){
    //             counts[5] +=1
    //             mainCounts[5] +=1
    //           }
    //           else{
    //             counts[0] += 1
    //             mainCounts[0] +=1
    //           }
    //         };
    //         // console.log("counts",counts)
            

    //         // average per overallperformance value
    //         for(let [key2, value] of Object.entries(counts)){
    //           // total vertical per service
    //           rowsOverallPerformance.value.forEach(function (arrayItem) {
    //             if(key2 == arrayItem.id){
    //               value = parseFloat((value/ sample.length) * 100)
    //               if(isNaN(value)){
    //                 value = '0%'
    //               }else{
    //                 value = value.toFixed(2).toString() + '%'
    //               }
                  
    //               arrayItem[stringColField] = value
    //             }
                
    //             });
    //           }
    //     })

    //      // Number of customers Row generation
        
    //     // group by months
        
        
    //     // total Respondents per month
    //       let totalRespondents = 0
    //       divisionsAndSections.value.forEach(key => {
                  
    //         let stringColField = key.keyname
    //         let resultTotal = rowsnumberOfCustomers.value.map(a => {
    //           if(isNaN(a[stringColField])){
    //               a[stringColField] = 0
    //           }
    //           return a[stringColField]
    //         })
    //         // console.log("res", resultTotal)
    //         let atotal = resultTotal.reduce((a, b) => a + b, 0)
            
    //         // totalActualRespondents.value[stringColField] = atotal
    //         let tempObj = {}
    //         tempObj['value'] = atotal
    //         totalRespondents += atotal
    //         totalActualRespondents.value.push(tempObj)
    //       })
    //       // total respondents push to last array
    //       let total = {}
    //       total['value'] = totalRespondents
    //       totalActualRespondents.value.push(total)
          
          
        


    //     // total row add percentage field
    //     let totalPercentRow = 0
        
    //     rowsOverallPerformance.value.forEach(row => {
    //       let res = parseFloat(mainCounts[row.id]/ totalAnswerOverall.value.length * 100)
    //       totalPercentRow +=res
    //       // console.log("mainco", mainCounts[row.id])
    //       // console.log("rowid", row.id)
    //       // console.log("totalPercentRow", totalPercentRow)
    //       // chartDataModelData.push(mainCounts[row.id])
    //       row['countOverall'] = mainCounts[row.id]
    //       row['percentage'] = res.toFixed(2).toString() + '%'
          
          
    //     });
    //     //total
    //     let tempObj = {}
    //     tempObj['value'] = totalPercentRow.toFixed(2).toString() + '%'
    //     totalPerField.value.push(tempObj)
    //     // console.log("totalPerField",totalPerField.value)

    //     divisionsAndSections.value.forEach(key => {
          
    //         let tempSecDivObj = {}
    //         let service = key.keyname
    //         let a = rowsOverallPerformance.value.map(a => a[service]);
    //         let sum = a.reduce((a, b) => parseFloat(a) + parseFloat(b), 0)
    //         sum = Math.round(sum)
    //         tempSecDivObj['value'] = sum.toFixed(2).toString() + '%'
    //         totalPerField.value.push(tempSecDivObj)
            
    //     })

    //       timer = void 0
    //       $q.loading.hide()



    //       loadCharts()
          

          
    //   }

      function buildTable(){
        buildColumns()
        buildRowsOverallPerformance()
        
        totalNoResponse.value = totalTsrs.value - totalAnswerOverall.value.length
      }
      function buildRowsOverallPerformance (){

        // performance row generation
        rowsOverallPerformance.value.push({servicearea: "5 - Outstanding" , id: 5,countOverall:0})
        rowsOverallPerformance.value.push({servicearea: "4 - Very Satisfactory" ,  id: 4 ,countOverall:0})
        rowsOverallPerformance.value.push({servicearea: "3 - Satisfactory", id: 3,countOverall:0})
        rowsOverallPerformance.value.push({servicearea: "2 - Fair", id: 2,countOverall:0})
        rowsOverallPerformance.value.push({servicearea: "1 - Poor", id: 1,countOverall:0})
        rowsOverallPerformance.value.forEach(row => {
          divisionsAndSections.value.forEach(element2 => {
          let stringColField = element2.keyname
          row[stringColField] = '0%'
          row['percentage'] = '0%'
        }); 
        })
        
        // rowsOverallPerformance.value.push({servicearea: "No Response", id: 0})
        
  
      
        }

        async function buildRowsCustomers (){
          // rowsnumberOfCustomers.value = await numberOfCustomersRowsData(divisionsAndSections.value,tsrlist)
        // performance row generation
          rowsnumberOfCustomers.value.push({month: "January" , id: 1, total: 0})
          rowsnumberOfCustomers.value.push({month: "February" ,  id: 2 ,total: 0})
          rowsnumberOfCustomers.value.push({month: "March", id: 3,total: 0})
          rowsnumberOfCustomers.value.push({month: "April", id: 4,total: 0})
          rowsnumberOfCustomers.value.push({month: "May", id: 5,total: 0})
          rowsnumberOfCustomers.value.push({month: "June" , id: 6,total: 0})
          rowsnumberOfCustomers.value.push({month: "July" ,  id: 7,total: 0 })
          rowsnumberOfCustomers.value.push({month: "August", id: 8,total: 0})
          rowsnumberOfCustomers.value.push({month: "September", id: 9,total: 0})
          rowsnumberOfCustomers.value.push({month: "October", id: 10,total: 0})
          rowsnumberOfCustomers.value.push({month: "November" , id: 11,total: 0})
          rowsnumberOfCustomers.value.push({month: "December" ,  id: 12,total: 0 })
          // rowsnumberOfCustomers.value.push({month: "Total Actual Respondents" ,  id: 13,total: 0 })
          
  
      
        }

        function filterMyArr (myArr, condition) {
          return myArr.map(element => element[condition])
        }

      // remove duplicate months

      async function buildColumns(){

        // colsnumberOfCustomers.value = await numberOfCustomersColumnsData 

        // colsOverallPerformance tables
        colsOverallPerformance.value.push( {
            name: 'Service Area',
            align: 'left',
            label: 'Service Area/Rating',
            field: 'servicearea',
            sortable: true
          })
        colsOverallPerformance.value.push( {
          name: 'Percentage (Overall)',
          align: 'center',
          label: 'Percentage',
          field: 'percentage',
          sortable: true
        })
        colsnumberOfCustomers.value.push({
          name: 'Month',
          align: 'left',
          label: 'Month',
          field: 'month',
          sortable: true
        })
        divisionsAndSections.value.forEach(element => {
          let stringColField = element.keyname
          let col = { name: element.service, align: 'center', label: element.service, field: stringColField, sortable: true }
          // columns for overallperformance
          colsOverallPerformance.value.push(col)
          // columns for number of customers
          colsnumberOfCustomers.value.push(col)
        }); 
          
          
        
        // console.log("buhay", colsnumberOfCustomers.value, colsOverallPerformance.value)

        colsnumberOfCustomers.value.push({
          name: 'Total',
          align: 'center',
          label: 'Total',
          field: 'total',
          sortable: true
        })

        // console.log("colsnumberOfCustomers",colsnumberOfCustomers.value)

      }


      async function callCardData(mode){

        // build columns card data

        pagination.value = {
          sortBy: 'desc',
          descending: false,
          page: 1,
          rowsPerPage: 10,
          rowsNumber: 5,
          mode: mode
        }
      

        if(cardDataCols.value.length == 0){

          cardDataCols.value.push( {
              name: 'tsrNo',
              align: 'left',
              label: 'TSR Number',
              field: 'tsrNo'
            })
          cardDataCols.value.push( {
              name: 'division',
              align: 'left',
              label: 'Division',
              field: 'division'
            })
          cardDataCols.value.push( {
              name: 'service',
              align: 'left',
              label: 'Service',
              field: 'service'
            })
          cardDataCols.value.push( {
              name: 'question',
              align: 'left',
              label: 'Question',
              field: 'question'
            })
          cardDataCols.value.push( {
              name: 'value',
              align: 'left',
              label: 'Value',
              field: 'value'
          })
          cardDataCols.value.push( {
              name: 'date',
              align: 'left',
              label: 'Submitted Date',
              field: 'submittedAt'
            })
          cardDataCols.value.push( {
            name: 'remarks',
            align: 'left',
            label: 'Remarks',
            field: 'remarks'
            })
          }
        

        await onRequestCard({
          pagination: pagination.value,
          filter: undefined
        })

        
        
        cardModal.value = true

        
      }

      async function fetchFromServer (startRow, count, filter, sortBy, descending, mode) {
       
        let rows = []
        // if(filter){

        // }else{
        if (filter){
          rows = await getAnswerBySearch(filter,mode,startRow,count)
        }else{
          if(yearTsr.value){
            if (mode == 1) {
              // console.log("here")
              rows = await getNegativeFeedbackData(startRow,count,yearTsr.value)
              cardTitle.value = "Negative Feedback " + yearTsr.value.toString()
            }else{
              rows = await getPositiveFeedbackData(startRow,count,yearTsr.value)
              cardTitle.value = "Positive Feedback " + yearTsr.value.toString()
            }
          }
          else if(quarterTSR.value){
            if (mode == 1) {
              rows = await getNegativeFeedbackDataRange(startRow,count,beforeDate.value,afterDate.value)
              cardTitle.value = "Negative Feedback Quarter:" + quarterTSR.value + " ," + beforeDate.value.getFullYear().toString()
            }else{
              rows = await getPositiveFeedbackDataRange(startRow,count,beforeDate.value,afterDate.value)
              cardTitle.value = "Positive Feedback Quarter:" + quarterTSR.value + " ," + beforeDate.value.getFullYear().toString()
            }
          }
          else if(beforeDate.value && afterDate.value){
            if (mode == 1) {
              rows = await getNegativeFeedbackDataRange(startRow,count,beforeDate.value,afterDate.value)
              cardTitle.value = "Negative Feedback " + beforeDate.value + ' - ' + afterDate.value
            }else{
              rows = await getPositiveFeedbackDataRange(startRow,count,beforeDate.value,afterDate.value)
              cardTitle.value = "Positive Feedback " + beforeDate.value + ' - ' + afterDate.value
            }
          }
          else{
            let currYear = new Date().getFullYear()
            if (mode == 1) {
              
              rows = await getNegativeFeedbackData(startRow,count,currYear)
              cardTitle.value = "Negative Feedback " + currYear.toString()
            }else{
              rows = await getPositiveFeedbackData(startRow,count,currYear)
              cardTitle.value = "Positive Feedback " + currYear.toString()
            }
          }
        }
        // }
        
        
        
      return rows
      
    }

      async function onRequestCard(props){

      console.log("props", props)
      const { page, rowsPerPage, sortBy, descending, mode } = props.pagination
      const filter = props.filter

      // loading.value = true
      // overallLoading.value = true

      // check whether there is a given date
      // if(beforeDate.value && afterDate.value){
      //   // beforeDate.value =  dateTime(beforeDate.value)
      //   // afterDate.value =  dateTime(afterDate.value)
      //   totalTsrsCount.value = await totalTsrsCount(beforeDate.value, afterDate.value,filter)
        
      // }else{
      //   let currYear = new Date().getFullYear()
      //   totalTsrsCount.value  = await totalTsrsCountByYear(currYear,filter)
      // }

      //
      // if(rowsOverall.value.length ==0){
      //   // rows overall generate data
      //   for (let i=0; i<orderByPositionQuestions.value.length ; i++){
      //   let row = {
      //     dimension: orderByPositionQuestions.value[i].description,
      //     id: orderByPositionQuestions.value[i].id
      //   }
      //     if(orderByPositionQuestions.value[i].question_type.id == 2){
      //       rowsOverall.value.push(row)
      //     }
        
      //  }
       
      // }
      if (yearTsr.value){
        totalNegative.value = await countNegativeFeedback(yearTsr.value)
        totalPositive.value = await countPositiveFeedback(yearTsr.value)
      }else if(quarterTSR.value || beforeDate.value || afterDate.value ){
        totalNegative.value = await countNegativeFeedbackByDateRange("","",beforeDate.value,afterDate.value)
        totalPositive.value = await countPositiveFeedbackByDateRange("","",beforeDate.value,afterDate.value)
      }
      
      let totalCount 
      if(mode == 1){
        totalCount = totalNegative.value
      }else{
        totalCount = totalPositive.value
      }
      


      // loading.value = true

      // emulate server
       

       // pagination count
        
        // get all rows if "All" (0) is selected
        
        

        // calculate starting row of data
        if(filter){
          let x = await countAnswerBySearch(filter,mode)
          pagination.value.rowsNumber = x
          const fetchCount = rowsPerPage === 0 ? x : rowsPerPage
          const startRow = (page - 1) * rowsPerPage
          // console.log("eyfilter", startRow,fetchCount)
          const returnedData = await fetchFromServer(startRow, fetchCount, filter, sortBy, descending,mode) 
          // console.log("returnedData",returnedData)
          // fetch data from "server"
          
          // clear out existing data and add new
          
          rows.value.splice(0, rows.value.length, ...returnedData)
          rows.value  = rows.value.map(card =>  ({
            // console.log("cardlog", card)
            // may papalitan pa dito ibalik yung q
            // let obj = { 
              value: card.value, 
              tsrNo: card.tsrNo,
              division: card.division,
              service: card.service,
              submittedAt: moment(card.submittedAt).format('YYYY-MM-DD'),
              question: card.question,
              remarks: card.remarks
            // }
            // return obj
            })
          )
        }else{
          const startRow = (page - 1) * rowsPerPage
          pagination.value.rowsNumber = totalCount
          const fetchCount = rowsPerPage === 0 ? totalCount : rowsPerPage
          // console.log("eytotal", startRow,fetchCount)
          const returnedData = await fetchFromServer(startRow, fetchCount, filter, sortBy, descending,mode) 
          // console.log("returnedData",returnedData)
          // fetch data from "server"
          
          // clear out existing data and add new
          
          rows.value.splice(0, rows.value.length, ...returnedData)
          rows.value  = rows.value.map(card =>  ({
            // console.log("cardlog", card)
            // may papalitan pa dito ibalik yung q
            // let obj = { 
              value: card.value, 
              tsrNo: card.tsr.tsrNo,
              division: card.tsr.division,
              service: card.tsr.service,
              submittedAt: moment(card.tsr.submittedAt).format('YYYY-MM-DD'),
              question: card.question.description,
            // }
            // return obj
            })
          )
        }
        
        


        // don't forget to update local pagination object
        pagination.value.page = page
        pagination.value.rowsPerPage = rowsPerPage
        pagination.value.sortBy = sortBy
        pagination.value.descending = descending
        pagination.value.mode = mode

        // ...and turn of loading indicator
      }

      async function submitDate(){
        showLoading()
        

        
        await updateTables()
        await LoadFeedbackCountsDateRange(beforeDate.value,afterDate.value)
        clearTimeout(timer)
        $q.loading.hide()

      }

      
      onMounted( async () => {
        // call functions upon start up here
        showLoading()
        divisionsAndSections.value = await getDivList()
        divisions.value = await getCountServicePerDivision()

        // 
        
        LoadFeedbackCounts(currentYear.value)
        // build tables
        await buildTable()

        await updateTables()

        // yearTsr.value = currentYear.value
      })


      return {
        totalNegative, 
        totalPositive,
        totalNoFeedback,
        totalTsrs, 
        CardDashboardFeedbackCount, 
        columns,
        divisions,
        divisionsAndSections,
        services,
        rowsOverallPerformance,
        rowsnumberOfCustomers,
        colsOverallPerformance,
        colsnumberOfCustomers,
        totalActualRespondents,
        totalPerField,
        yearOptions,
        yearTsr,
        updateTables,
        beforeDate,
        afterDate,

        // chart data
        chartDataModelData,
        chartDataModelLabel,

        // customerchart,
        chartDataModelCustomersLabel,
        chartDataModelCustomersData,
        chartDataModelNumberPerServiceArea,
        lineChartLabel,

        //card data
        showTextCard,
        cardDataCols,
        mode,
        filter,
        // card methods
        cardData,
        callCardData,
        maximizedToggle,
        cardModal
        ,cardTitle,

        //pagination
        pagination,
        onRequestCard,
        rows,
        currentYear,

        modeOptions,
        modeDashboard,
        yearTsrQuarter,
        quarterOptions,
        quarterTSR,

        submitDate
      };
    },
  }
</script>
<style scoped>



    

</style>
